<h1>Containerization</h1>

**Containerization** is a lightweight form of virtualization that involves encapsulating an application and its dependencies into a container that can run on
any system. This ensures consistency across multiple environments, such as development, testing, and production.

### Docker

**Docker** is the most popular containerization platform.
It simplifies the process of managing application containers and has become an essential tool in modern software development.

### Container Fundamentals

- **Container**: A standardized unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing
  environment to another.
- **Image**: A lightweight, stand-alone, executable package that includes everything needed to run a piece of software, including the code, runtime, libraries,
   and system tools.
- **Docker Engine**: The runtime that allows you to build and run containers.
- **Registry**: A storage and distribution system for Docker images (e.g., Docker Hub).

### Key Concepts

1. **Isolation**: Containers provide process and file system isolation, ensuring applications do not interfere with each other.
2. **Portability**: Containers can run on any system that supports the Docker runtime, making them highly portable across different environments.
3. **Efficiency**: Containers share the host system's kernel, which makes them more lightweight and faster to start compared to traditional virtual machines.

### Dockerfiles

A **Dockerfile** is a text document that contains all the commands a user could call on the command line to assemble an image. 
Using a Dockerfile is the standard way to create custom Docker images.

### Structure of a Dockerfile

1. **FROM**: Specifies the base image to use for the subsequent instructions.
   ```dockerfile
   FROM ubuntu:20.04
   ```
2. **RUN**: Executes a command in the container.
   ```dockerfile
   RUN apt-get update && apt-get install -y python3
   ```
3. **COPY**: Copies files from the host machine into the container.
   ```dockerfile
   COPY . /app
   ```
4. **WORKDIR**: Sets the working directory for any subsequent instructions.
   ```dockerfile
   WORKDIR /app
   ```
5. **CMD**: Provides a command to run within the container.
   ```dockerfile
   CMD ["python3", "app.py"]
   ```

### Example Dockerfile

```dockerfile
# Use an official Python runtime as a base image
FROM python:3.8-slim-buster

# Set the working directory in the container
WORKDIR /usr/src/app

# Copy the current directory contents into the container
COPY . .

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
```

### Docker Compose

**Docker Compose** is a tool for defining and running multi-container Docker applications.
It uses a YAML file to configure the applicationâ€™s services, networks, and volumes.

### Key Concepts

- **Service**: A service in Docker Compose is an application component, such as a web server or database.
- **Network**: Networks enable communication between services within the Docker environment.
- **Volume**: Volumes are used to persist data generated by and used by Docker containers.

### Example docker-compose.yml

This example demonstrates a simple web application with a web service and a database service.

```yaml
version: '3'

services:
  web:
    image: my-web-app
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db

  db:
    image: postgres:12
    environment:
      POSTGRES_USER: example
      POSTGRES_PASSWORD: example
      POSTGRES_DB: exampledb
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
```

### Docker Compose Workflow

1. **Define Services**: Create a `docker-compose.yml` file to define the services that make up the application.
2. **Build and Start**: Use `docker-compose up` to build and start the entire application.
3. **Scale Services**: Use `docker-compose scale` to adjust the number of instances for a service.
4. **Shutdown**: Use `docker-compose down` to stop and remove all containers defined in the file.

### Summary

Containerization with Docker streamlines the deployment process by packaging applications and their dependencies into containers. Dockerfiles provide a 
way to automate the creation of Docker images, and Docker Compose simplifies the management of multi-container applications. By leveraging these tools,
developers can ensure consistent environments across different stages of development, testing, and production, improving both efficiency and reliability.
